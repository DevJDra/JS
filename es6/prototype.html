<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        //상속을 구현할 수 있는 또 하나의 문법 prototype
        //prototype = 유전자

        //기계(constructor)를 만들면 prototype이라는 공간이 자동으로 생김
        function 기계(이름){ 
            this.name = 이름;
            this.age = 15;
            this.sayHi = function(){
                console.log('안녕하세요 ' + this.name + '입니다')
            }
        }

        //prototype에 값을 추가하면 모든 자식들이 물려받기 가능
        기계.prototype.gender = '남';

        //prototype의 동작원리
        
        학생1.name;
        //1. 학생1이 직접 name을 가지고 있는가 ?
        //2. 그럼 학생1의 부모 유전자가 gender를 가지고 있는가 ? 그럼 실행!
        학생1.gender;
        //그럼 부모의 부모 유전자에 있는가 ?
        학생1.toString(); //Object/Array에 붙일 수 있는 내장함수, 부모의 부모 유전자

        var arr = [1,2,3];
        var arr = new Array(1,2,3); //실제 array가 만들어지는 방식, array 만드는 기계로부터 하나 뽑음

        //arr에 sort이런거 부여한 적 없음
        //근데 쓸 수 있는 이유는..
        //arr의 부모 유전자가 sort를 가지고 있기 때문
        //1. arr에 sort()가 있는가?
        //2. 그럼 arr 부모의 유전자에 sort()가 있는가?
        arr.sort();
        arr.map();
        arr.push();

        var obj = { name : 'Kim'};
        var obj = new Object();

        //Prototype 특징 
        //1. prototype은 함수에만 몰래 생성됨
        //2. 내 부모 유전자(부모의 prototype)를 검사하고 싶다면 __proto__
        //3. __proto__를 이용해 부모님 강제 등록하기
        var 부모 = { name : 'Kim'};
        var 자식 = {};
        자식.__proto__ = 부모; //나의 부모유전자는 이걸로 해주세요~
        자식.name;

        //4. 콘솔창에서 알려주는 prototype chain
    </script>
</body>
</html>